/* Generated by Streams Studio: June 27, 2017 at 3:24:35 PM EDT */
package com.ibm.streamsx.health.control.patientcontrolplane.operator;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.Logger;

import com.google.common.base.Joiner;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.ProcessingElement;
import com.ibm.streams.operator.control.ControlPlaneContext;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streamsx.health.control.patientcontrolplane.operator.adapter.ExternalServerAdapter;
import com.ibm.streamsx.health.control.patientcontrolplane.operator.adapter.RedisServerAdapter;
import com.ibm.streamsx.health.control.patientcontrolplane.operator.adapter.RedisServerListener;

@PrimitiveOperator(name = "BridgeOp", namespace = "com.ibm.streamsx.health.control.patientcontrolplane", description = "Provides a bridge between the JCP and a backend server (i.e. Redis)")
@Libraries("opt/downloaded/*")
public class BridgeOp extends AbstractOperator {
	
	@SuppressWarnings("unused")
	private static final Logger logger = Logger.getLogger(BridgeOp.class);

	private String connection;
	private String serviceName;
	private String serviceType;
	private List<String> outputTopics;
	private String appConfigName;

	private ExternalServerAdapter server;
	
	private ControlPlaneContext cpc;
	private BridgeControllable controller;
	private Gson gson;
	
	@Parameter(optional = false)
	public void setServiceType(String serviceType) {
		this.serviceType = serviceType;
	}
	
	@Parameter(optional = true)
	public void setConnection(String connection) {
		this.connection = connection;
	}

	@Parameter(optional = false)
	public void setServiceName(String serviceName) {
		this.serviceName = serviceName;
	}

	@Parameter(optional = true)
	public void setOutputTopics(String outputTopics) {
		this.outputTopics = Arrays.asList(outputTopics.split(","));
	}
	
	@Parameter(optional = false)
	public void setAppConfigName(String appConfigName) {
		this.appConfigName = appConfigName;
	}
	
	/**
	 * Initialize this operator. Called once before any tuples are processed.
	 * 
	 * @param context
	 *            OperatorContext for this operator.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void initialize(OperatorContext context) throws Exception {
		// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);

		gson = new Gson();
		
		// prevent the runtime from shutting down this operator
		createAvoidCompletionThread(context);

		cpc = context.getOptionalContext(ControlPlaneContext.class);
		controller = new BridgeControllable(cpc);
		cpc.connect(controller);
		
		while(!controller.isConnected()) {
			System.out.println("Waiting for CPC connection...");
			Thread.sleep(1000);
		}
		System.out.println("CPC Connected!");
		
		System.out.println("ControlPlaneContext connection established");
						
		ProcessingElement pe = getOperatorContext().getPE();
		ServiceInfo serviceInfo = new ServiceInfo(pe.getJobId(), pe.getJobName(), ServiceInfo.Status.RUNNING, ServiceType.valueOf(serviceType.toUpperCase()));

		if(connection == null || connection.equals("")) {
			Map<String, String> appConfig = pe.getApplicationConfiguration(appConfigName);
			if(appConfig.containsKey("connection")) {
				connection = appConfig.get("connection");
			}
		}
		
		server = new RedisServerAdapter(serviceName, connection, new RedisServerListener() {
			
			@Override
			public void patientsUpdated(Collection<String> patients) {
				try {
					updatePatients(patients);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			
			@Override
			public void alertRulesUpdated(Collection<String> alertRules) {
				try {
					updateAlertRules(alertRules);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		server.registerService(serviceInfo);
		server.registerServiceTopics(outputTopics);
		updateAlertRules(server.getAlerts());
		
		// background thread that listens for updates
		// to the global patient list
		GlobalPatientRunner globalPatientRunner = new GlobalPatientRunner(controller, server);
		context.getScheduledExecutorService().scheduleAtFixedRate(globalPatientRunner, 0l, 1l, TimeUnit.SECONDS);
	}
	
	@Override
	public void allPortsReady() throws Exception {
		super.allPortsReady();
		
		// re-add previously added patients 
		Collection<String> patients = server.getServicePatients();
		updatePatients(patients);
	}
	
	private void updateAlertRules(Collection<String> alerts) throws Exception {
		JsonArray jsonArray = new JsonArray();
		alerts.forEach(alert -> jsonArray.add(gson.fromJson(alert, JsonObject.class)));
		controller.getUpdatedAlertRulesCV().setValue(gson.toJson(jsonArray));
		System.out.println("updateAlerts():" + alerts);
	}
	
	private void updatePatients(Collection<String> patients) throws Exception {		
		controller.getServicePatientsCV().setValue(Joiner.on(",").join(patients));
		System.out.println("updatePatients(): " + patients);
	}

	@Override
	public void shutdown() throws Exception {
		server.unregisterService();
		server.close();
		
		super.shutdown();
	}
}
