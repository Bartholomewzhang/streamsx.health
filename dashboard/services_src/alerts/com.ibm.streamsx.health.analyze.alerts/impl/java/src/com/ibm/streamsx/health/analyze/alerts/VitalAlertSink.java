/* Generated by Streams Studio: August 22, 2017 at 8:11:11 AM EDT */
package com.ibm.streamsx.health.analyze.alerts;


import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.lambdaworks.redis.RedisClient;
import com.lambdaworks.redis.api.sync.RedisCommands;

@PrimitiveOperator(name="VitalAlertSink", namespace="com.ibm.streamsx.health.analyze.alerts",
description="Java Operator VitalAlertSink")
@InputPorts({@InputPortSet(description="Port that ingests tuples", cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@Libraries({"opt/downloaded/*"})
public class VitalAlertSink extends AbstractOperator {
	
	private String connection;
	private RedisCommands<String, String> sync;
	private Gson gson;
	
	private Map<String /* patientId */, Map<String /* alert name */, String /* alert data (JSON) */>> activeAlertMap;
	
	private static final String ALERT_KEY_PREFIX = "com.ibm.streamsx.health:alerts:";
	private static final String ACTIVE_ALERT_KEY_PREFIX = "com.ibm.streamsx.health:alerts:active:";
	
	@Parameter(name="connection", optional=true)
	public void setConnection(String connection) {
		this.connection = connection;
	}
	
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );        
        
        activeAlertMap = new HashMap<String, Map<String,String>>();
        gson = new Gson();
        
		if(connection == null || connection.equals("")) {
			Map<String, String> appConfig = context.getPE().getApplicationConfiguration("patient_control_plane");
			if(appConfig.containsKey("connection")) {
				connection = appConfig.get("connection");
			}
		}
        
		String redisConnectionString = "redis://" + connection;
        RedisClient client = RedisClient.create("redis://" + connection);
        sync = client.connect().sync();
        System.out.println("Connected to: " + redisConnectionString);
	}

    @Override
    public synchronized void allPortsReady() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    @Override
    public void process(StreamingInput<Tuple> stream, Tuple tuple)
            throws Exception {
    	String patientId = tuple.getString("patientId");
    	String alertMessage = tuple.getString("alert");
    	JsonObject jsonObj = gson.fromJson(alertMessage, JsonObject.class);
    	long epochSeconds = jsonObj.get("epochSeconds").getAsLong();
    	    	
    	sync.zadd(ALERT_KEY_PREFIX + patientId, epochSeconds, alertMessage);
    	
    	updateActiveAlerts(patientId, jsonObj, tuple);
    }
    
    private void updateActiveAlerts(String patientId, JsonObject alertMessage, Tuple tuple) {
    	System.out.println("TUPLE: " + tuple);
    	
    	String ruleName = alertMessage.get("ruleName").getAsString();
    	String type = alertMessage.get("type").getAsString();
    	
		Map<String, String> activeAlerts = activeAlertMap.get(patientId);
		if(activeAlerts == null) {
			activeAlerts = new HashMap<String, String>();
			activeAlertMap.put(patientId, activeAlerts);
		}
		
    	if(type.equals("ALERT_TRIGGERED")) {
    		String description = alertMessage.get("description").getAsString();
    		String vitalName = tuple.getTuple("reading").getTuple("readingType").getString("code");
    		long ts = alertMessage.get("epochSeconds").getAsLong();
    		
    		JsonObject alertData = new JsonObject();
    		alertData.addProperty("alertName", ruleName);
    		alertData.addProperty("description", description);
    		alertData.addProperty("vitalName", vitalName);
    		alertData.addProperty("ts", ts);
    		
    		activeAlerts.put(ruleName, gson.toJson(alertData));
    	} else if(type.equals("ALERT_CANCELED")) {
    		activeAlerts.remove(ruleName);
    	}
    	
    	// remove non-existent keys
   		List<String> fields = sync.hkeys(ACTIVE_ALERT_KEY_PREFIX + patientId);
		for(String field : fields) {
			if(!activeAlerts.containsKey(field)) {
				sync.hdel(ACTIVE_ALERT_KEY_PREFIX + patientId, field);
			}
		}
    	    	
    	if(!activeAlerts.isEmpty()) {
    		sync.hmset(ACTIVE_ALERT_KEY_PREFIX + patientId, activeAlerts);
    	}
	}

	@Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    }

    @Override
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        super.shutdown();
    }
    
}
