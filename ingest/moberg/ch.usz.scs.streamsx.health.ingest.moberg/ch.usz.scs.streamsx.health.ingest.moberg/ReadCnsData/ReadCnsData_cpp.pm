
package ReadCnsData_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '#define PLATFORM_LINUX', "\n";
   print "\n";
   print '#include "icu/cns/IcuDataAccess.h"', "\n";
   print '#include "icu/cns/IcuDataSource.h"', "\n";
   print '#include "icu/cns/IcuCnsAccessWrapperException.h"', "\n";
   print "\n";
   print '#include <vector>', "\n";
   print '#include <limits>', "\n";
   print '#include <time.h>', "\n";
   print '#include <exception>', "\n";
   print "\n";
   print "\n";
   print "\n";
   my $isNtpPort = ($model->getNumberOfInputPorts()==2)?1:0;
   print "\n";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR():', "\n";
   print '		current_context_(NULL), next_context_(NULL), context_change_needed_(false), ', "\n";
   print '		current_is_valid_(false), next_is_valid_(false),', "\n";
   print '		current_start_time_(0L), next_start_time_(0L)', "\n";
   print '{', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: Constructor", "");', "\n";
   print "\n";
   print '	// get value from SPL', "\n";
   print '	';
   		my $cnsArchiveRootParam = $model->getParameterByName("cnsArchiveRoot");
   		my $cnsArchiveRootValue = $cnsArchiveRootParam->getValueAt(0)->getCppExpression();
   
   		my $cnsSleepMsParam = $model->getParameterByName("cnsSleepMs");
   		my $cnsSleepMsValue = (not $cnsSleepMsParam) ? "0" : $cnsSleepMsParam->getValueAt(0)->getCppExpression();
   		
   		my $cnsPayloadDurationUsecParam = $model->getParameterByName("cnsPayloadDurationUsec");
   		my $cnsPayloadDurationUsecValue = (not $cnsPayloadDurationUsecParam) ? "0" : $cnsPayloadDurationUsecParam->getValueAt(0)->getCppExpression();
   	
   print "\n";
   print '	cns_archive_ = ';
   print $cnsArchiveRootValue;
   print ';', "\n";
   print '	cns_sleep_ms_ = ';
   print $cnsSleepMsValue;
   print ';', "\n";
   print '	cns_payload_duration_usec_ = ';
   print $cnsPayloadDurationUsecValue;
   print ';', "\n";
   print '	', "\n";
   if (!$isNtpPort) {
   print "\n";
   print '    // TODO:  Samantha Review timestamp changes', "\n";
   print '	SPL::timestamp ts = Functions::Time::getTimestamp();', "\n";
   print '	int64 seconds = Functions::Time::getSeconds(ts);', "\n";
   print '	int64 nano = (int64)Functions::Time::getNanoseconds(ts);', "\n";
   print '	', "\n";
   print '	int64 epocMicro = nano*0.001;', "\n";
   print '	epocMicro += seconds * 1000000;', "\n";
   print '	', "\n";
   print '	handleStartTime(epocMicro);', "\n";
   }
   print '    ', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() {', "\n";
   print '	// Finalization code goes here', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: Destructor", "");', "\n";
   print '	', "\n";
   print '	delete current_context_;', "\n";
   print '	delete next_context_;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() {', "\n";
   print '	// Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '	// this. Source operators can use this method to spawn threads.', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: allPortsReady", "");', "\n";
   print "\n";
   print '	createThreads(1); // Create source thread', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() {', "\n";
   print '	// This is an asynchronous call', "\n";
   print "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: prepareToShutdown", "");', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print '// This is where patientInfo input-tuples get processed', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: process (const Tuple&, port) on port " << port, "");', "\n";
   print "\n";
   print '	if (port == 0) {', "\n";
   print '		', "\n";
   print '		IPort0Type const & tuple_patient = static_cast<IPort0Type const &>(tuple);', "\n";
   print '		SPL::rstring pid = tuple_patient.get_patientId();', "\n";
   print '		SPL::rstring mrn = tuple_patient.get_MedicalRecordNumber();', "\n";
   print '		bool is_valid_patient = tuple_patient.get_isValid();', "\n";
   print "\n";
   print '		handlePatient(pid, mrn, is_valid_patient);', "\n";
   print '			', "\n";
   print '	} ', "\n";
   print '	', "\n";
   if ($isNtpPort) {
   print "\n";
   print '	else if (port == 1) {', "\n";
   print '		', "\n";
   print '		IPort1Type const & tuple_cns_time = static_cast<IPort1Type const &>(tuple);', "\n";
   print '		SPL::int64 start_time = tuple_cns_time.get_OtherSystemTimeEpocMicro();', "\n";
   print "\n";
   print '		handleStartTime(start_time);', "\n";
   print '	}', "\n";
   }
   print "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::handleStartTime(const ClockTime start_time) {', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '		next_start_time_ = start_time;', "\n";
   print '	}', "\n";
   print '	SPLAPPTRC(L_INFO, "CNS next start time: \'" << start_time << "\' [epoc micro].", "");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::handlePatient(const std::string& next_pid, const std::string& next_mrn, const bool next_is_valid) {', "\n";
   print "\n";
   print '	if(context_change_needed_) {', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	std::string current_mrn = getCurrentMrn();', "\n";
   print '	bool current_is_valid = getCurrentPatientIsValid();', "\n";
   print '	', "\n";
   print '	if ( !current_is_valid && next_is_valid) {', "\n";
   print "\n";
   print '		createNextContext(next_pid, next_mrn);', "\n";
   print '		openPatientDirectory(next_pid, next_mrn);', "\n";
   print "\n";
   print '		SPLAPPTRC(L_INFO, "New patient admitted with medical record number \'" << next_mrn << "\'.", "");', "\n";
   print "\n";
   print '	} else if (current_is_valid && !next_is_valid) {', "\n";
   print '		deleteNextContext();', "\n";
   print '		', "\n";
   print '		SPLAPPTRC(L_INFO, "Patient with medical record number \'" << current_mrn << "\' got discharged.", "");', "\n";
   print '	} else if (current_is_valid && next_is_valid && (next_mrn.compare(current_mrn) != 0)) {', "\n";
   print "\n";
   print '		createNextContext(next_pid, next_mrn);', "\n";
   print '		openPatientDirectory(next_pid, next_mrn); // needs to be updated because context will change', "\n";
   print "\n";
   print '		SPLAPPTRC(L_INFO, "Currently admitted patient has a new medical record number \'" << next_mrn << "\'.", "");', "\n";
   print "\n";
   print '	}', "\n";
   print '	// else do nothing', "\n";
   print '	', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx) {', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: process(" << idx <<")", "");', "\n";
   print "\n";
   print '	int run = 0;', "\n";
   print "\n";
   print '	while (!getPE().getShutdownRequested()) {', "\n";
   print '		', "\n";
   print '		try {', "\n";
   print "\n";
   print '			struct timespec pause = {0};', "\n";
   print '			pause.tv_sec = 0;', "\n";
   print '			pause.tv_nsec = cns_sleep_ms_ * 1000000L;', "\n";
   print '			nanosleep(&pause, (struct timespec *)NULL);', "\n";
   print '	', "\n";
   print '			switchPatientIfNeeded();', "\n";
   print '			', "\n";
   print '			// quick way out if we don\'t have a patient directory', "\n";
   print '			if (current_context_ == NULL)', "\n";
   print '			{', "\n";
   print '				SPLAPPTRC(L_DEBUG, "No patient context.", "");', "\n";
   print '				continue;', "\n";
   print '			}		', "\n";
   print '			', "\n";
   print '			SPLAPPTRC(L_DEBUG, "Run \'" << run++ << "\'", "");', "\n";
   print '			', "\n";
   print '			std::vector < CNSDataAccess::CAspects > aspects = getCurrentAspects();', "\n";
   print '	', "\n";
   print '			for (size_t type_idx = 0; type_idx < aspects.size(); ++type_idx) {', "\n";
   print '				CNSDataAccess::CAspects& aspect = aspects.at(type_idx);', "\n";
   print '				', "\n";
   print '				try {', "\n";
   print '				', "\n";
   print '					CNSDataAccessWrapper::IcuDataSource* cns_source;', "\n";
   print '					{ AutoMutex am (context_mutex_); ', "\n";
   print '						cns_source = current_context_->dataAccess->getDataSource(aspect.baseTypeString()); ', "\n";
   print '					}', "\n";
   print '					', "\n";
   print '					', "\n";
   print '					if (cns_source == NULL) {', "\n";
   print '						SPLAPPTRC(L_INFO, "CNS data source not found for aspect \'" << aspect.toString() << "\'.", "");', "\n";
   print '						continue;', "\n";
   print '					}', "\n";
   print '		', "\n";
   print '					// replace the next line if you want to review data differently', "\n";
   print '					processAspectHistoricAndLive(aspect, cns_source);', "\n";
   print '	', "\n";
   print '				} catch(const CNSDataAccessWrapper::IcuCnsAccessWrapperException& e) {', "\n";
   print '					SPLAPPTRC(L_INFO, "IcuCnsAccessWrapperException exception during processing of aspect \'" << aspect.toString() << "\'. " << e.what(), "");', "\n";
   print '				} catch(const std::exception& e) {', "\n";
   print '					SPLAPPTRC(L_INFO, "Exception during processing of aspect \'" << aspect.toString() << "\'. " << e.what(), "");', "\n";
   print '				} catch(...) {', "\n";
   print '					SPLAPPTRC(L_INFO, "Unknown exception during processing of aspect \'" << aspect.toString() << "\'.", "");', "\n";
   print '				}', "\n";
   print '				', "\n";
   print '			} // end aspects', "\n";
   print '			SPLAPPTRC(L_TRACE, "Done all aspects.", "");', "\n";
   print '			', "\n";
   print '			', "\n";
   print '		} catch(const CNSDataAccessWrapper::IcuCnsAccessWrapperException& e) {', "\n";
   print '			SPLAPPTRC(L_INFO, "IcuCnsAccessWrapperException exception: " << e.what(), "");', "\n";
   print '		} catch(const std::exception& e) {', "\n";
   print '			SPLAPPTRC(L_INFO, "Exception: " << e.what(), "");', "\n";
   print '		} catch(...) {', "\n";
   print '			SPLAPPTRC(L_INFO, "Unknown exception during CNS Read process method for patient \'" << getCurrentMrn() << "\'.", "");', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_INFO, "Operator ReadCnsData: leaving process(" << idx <<")", "");', "\n";
   print "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAspectHistoricAndLive(CNSDataAccess::CAspects& aspect, CNSDataAccessWrapper::IcuDataSource* cns_source) {', "\n";
   print "\n";
   print '	CNSDataAccess::CPayload payload;', "\n";
   print "\n";
   print '	SPLAPPTRC(L_DEBUG, "Processing " ', "\n";
   print '			<< aspect.toString() ', "\n";
   print '			<< " from \'" ', "\n";
   print '			<< "\' ...", "");', "\n";
   print '	', "\n";
   print '	float64 m = updateSampleConversionsSlopeParam(cns_source, aspect.Type());', "\n";
   print '	float64 b = updateSampleConversionYInterceptParam(cns_source, aspect.Type());', "\n";
   print '	', "\n";
   print '	while (cns_source->read(cns_payload_duration_usec_, payload)) {', "\n";
   print '		', "\n";
   print '		SPLAPPTRC(L_DEBUG, "Payload count \'" << payload.Count() << "\', for type " << payload.Type(), "");', "\n";
   print '			', "\n";
   print '		if (payload.Type() == CNSDataAccess::CHAR_AGGREGATE) {', "\n";
   print '			SPLAPPTRC(L_TRACE, "Received new event...", "");', "\n";
   print '			', "\n";
   print '			submitEventTuples(payload);', "\n";
   print '		', "\n";
   print '		} else if (payload.Type() == CNSDataAccess::FLOAT_AGGREGATE ', "\n";
   print '				|| payload.Type() == CNSDataAccess::INTEGER_AGGREGATE', "\n";
   print '				|| payload.Type() == CNSDataAccess::COMPOSITE_AGGREGATE ) {', "\n";
   print "\n";
   print '			submitDataTuples(cns_source, payload, m, b);', "\n";
   print '				', "\n";
   print '		} else {', "\n";
   print '			SPLAPPTRC(L_WARN, "Unknown value type \'" << payload.Type() << "\'", "");								', "\n";
   print '		}', "\n";
   print '		', "\n";
   print '		SPLAPPTRC(L_TRACE, "Done reading.", "");', "\n";
   print '									', "\n";
   print '	} // end while loop payload', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Aspect \'" << aspect.toString() << "\' done.", "");', "\n";
   print "\n";
   print '}', "\n";
   print "\n";
   print '// TODO:  SAMANTHA - have to comment this code for it to compile', "\n";
   print '/*', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAspectLiveOnly(CNSDataAccess::CAspects& aspect, CNSDataAccessWrapper::IcuDataSource* cns_source) {', "\n";
   print '	SPLAPPTRC(L_DEBUG, "Processing " << aspect.toString(), "");', "\n";
   print '	', "\n";
   print '	CNSDataAccess::CPayload payload;', "\n";
   print '	cns_source->readLatest(payload);', "\n";
   print '	SPLAPPTRC(L_DEBUG, "Payload count \'" << payload.Count() << "\', for type " << payload.Type(), "");', "\n";
   print '	', "\n";
   print '	std::vector<ClockTime> sampleTimes;', "\n";
   print '	cns_source->getSampleTimestamps(payload, sampleTimes);', "\n";
   print '	if (sampleTimes.size() > 0) {', "\n";
   print '		ClockTime firstTimestamp = sampleTimes.at(0);', "\n";
   print '		', "\n";
   print '		// to ensure that timestamps are more or less within the current timeframe', "\n";
   print '		ClockTime current_time = getCurrentTime();', "\n";
   print '		if (isTimestampOutOfBound(firstTimestamp, current_time)) {', "\n";
   print '			SPLAPPTRC(L_WARN, "First timestamp for aspect \'" << aspect.toString() << "\' is out of bound (+/-24hours of current time).\\n"', "\n";
   print '					<< "\\tTimestamp = \'" << firstTimestamp << "\' epoc micro \\n"', "\n";
   print '					<< "\\tCurrent time = \'" << current_time << "\' epoc micro (from CNS NTP)\\n"', "\n";
   print '					<< "\\tPayload count = \'" << payload.Count() << "\'\\n"', "\n";
   print '					<< "\\tPayload type = \'" << payload.Type() << "\'\\n"', "\n";
   print '					<< "\\tPayload duration = \'" << cns_payload_duration_usec_ << "\' usec (in)\\n"', "\n";
   print '					<< "\\tPayload duration = \'" << payload.Duration() << "\' usec (out)\\n"', "\n";
   print '					, "");		', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '		', "\n";
   print '	if (payload.Type() == CNSDataAccess::CHAR_AGGREGATE) {', "\n";
   print '		SPLAPPTRC(L_DEBUG, "Received new event. However, it is currently not processed.", "");', "\n";
   print '		', "\n";
   print '		submitEventTuples(payload);', "\n";
   print '		', "\n";
   print '	} else if (payload.Type() == CNSDataAccess::FLOAT_AGGREGATE ', "\n";
   print '			|| payload.Type() == CNSDataAccess::INTEGER_AGGREGATE', "\n";
   print '			|| payload.Type() == CNSDataAccess::COMPOSITE_AGGREGATE ) {', "\n";
   print '		float64 m = updateSampleConversionsSlopeParam(cns_source, aspect.Type());', "\n";
   print '		float64 b = updateSampleConversionYInterceptParam(cns_source, aspect.Type());', "\n";
   print '		submitDataTuples(cns_source, payload, m, b);	', "\n";
   print '	} else {', "\n";
   print '		SPLAPPTRC(L_DEBUG, "Unknown value type \'" << payload.Type() << "\'", "");								', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_DEBUG, "Aspect \'" << aspect.toString() << "\' done.", "");', "\n";
   print '}', "\n";
   print '*/', "\n";
   print "\n";
   print 'ClockTime MY_OPERATOR_SCOPE::MY_OPERATOR::getCurrentTime() {', "\n";
   print '	ClockTime current_time = 0L;', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '	     current_time = next_start_time_;', "\n";
   print '	}', "\n";
   print '	return current_time;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::isTimestampOutOfBound(const ClockTime& start_time) {', "\n";
   print '	ClockTime current_time = getCurrentTime();', "\n";
   print '	', "\n";
   print '	bool out_of_bound = isTimestampOutOfBound(start_time, current_time);', "\n";
   print "\n";
   print '	return out_of_bound;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::isTimestampOutOfBound(const ClockTime& start_time, const ClockTime& current_time) {', "\n";
   print '	ClockTime current_time_bound = 86400000000; //24 hours in epoc micro seconds', "\n";
   print '	', "\n";
   print '	ClockTime lower_bound_current_time = current_time - current_time_bound;', "\n";
   print '	ClockTime upper_bound_current_time = current_time + current_time_bound;', "\n";
   print '	', "\n";
   print '	bool out_of_bound = false;', "\n";
   print '	if (start_time < lower_bound_current_time || start_time > upper_bound_current_time) {', "\n";
   print '		out_of_bound = true;', "\n";
   print '	}', "\n";
   print '	return out_of_bound;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::switchPatientIfNeeded() {', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '	', "\n";
   print '	    if (next_start_time_ == 0) {', "\n";
   print '			SPLAPPTRC(L_WARN, "Next recording start time is zero.", "");', "\n";
   print '	    	return;', "\n";
   print '	    }', "\n";
   print '		if (context_change_needed_) {', "\n";
   print '			SPLAPPTRC(L_INFO, "Switching patient context...", "");', "\n";
   print '			', "\n";
   print '			if (current_context_ != NULL ) {', "\n";
   print '				delete current_context_;', "\n";
   print '			}', "\n";
   print '			if (next_context_ != NULL ) {', "\n";
   print '				current_context_ = next_context_;', "\n";
   print '			}', "\n";
   print '			next_context_ = NULL;', "\n";
   print '			', "\n";
   print '			current_is_valid_ = next_is_valid_;', "\n";
   print '			', "\n";
   print '			current_start_time_ = next_start_time_;', "\n";
   print "\n";
   print '			context_change_needed_ = false;', "\n";
   print '		', "\n";
   print '			SPLAPPTRC(L_INFO, "Switched patient context.", "");', "\n";
   print '		', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'float64 MY_OPERATOR_SCOPE::MY_OPERATOR::updateSampleConversionsSlopeParam(', "\n";
   print '		CNSDataAccessWrapper::IcuDataSource* cns_source, ', "\n";
   print '		const std::string& type) const {', "\n";
   print '	float64 m = 1.0;', "\n";
   print '	if (type.compare("SampleSeries") == 0)', "\n";
   print '	{', "\n";
   print '		m =(float64)(cns_source->getSettingsFile().getM());	', "\n";
   print '		', "\n";
   print '		SPLAPPTRC(L_TRACE, "SampleSeries, conversion slope param m = \'" << m << "\'.", "");', "\n";
   print '	}', "\n";
   print '	return m;', "\n";
   print '}', "\n";
   print "\n";
   print 'float64 MY_OPERATOR_SCOPE::MY_OPERATOR::updateSampleConversionYInterceptParam(', "\n";
   print '		CNSDataAccessWrapper::IcuDataSource* cns_source, ', "\n";
   print '		const std::string& type) const {', "\n";
   print '	float64 b = 0.0;', "\n";
   print '	if (type.compare("SampleSeries") == 0)', "\n";
   print '	{', "\n";
   print '		b =(float64)(cns_source->getSettingsFile().getB());	', "\n";
   print '		', "\n";
   print '		SPLAPPTRC(L_TRACE, "SampleSeries, conversion b-intercept param b = \'" << b << "\'.", "");', "\n";
   print '	}', "\n";
   print '	return b;', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::submitDataTuples(', "\n";
   print '		CNSDataAccessWrapper::IcuDataSource* cns_source, ', "\n";
   print '		CNSDataAccess::CPayload& payload,', "\n";
   print '		const float64 m, const float64 b) {', "\n";
   print '	', "\n";
   print '	std::vector<ClockTime> sampleTimes;', "\n";
   print '	cns_source->getSampleTimestamps(payload, sampleTimes);', "\n";
   print '	std::string units = *cns_source->getSettingsFile().getUnits();', "\n";
   print '	SPLAPPTRC(L_DEBUG, "Unit = \'" << units << "\'.", "");', "\n";
   print "\n";
   print '	for (size_t i = 0; i < payload.Count(); i++) {', "\n";
   print '		processMeasurements(cns_source->getSettingsFile(), payload, sampleTimes[i], units, i, m, b);', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::submitEventTuples(CNSDataAccess::CPayload& payload) {', "\n";
   print '	', "\n";
   print '	for (size_t i = 0; i < payload.Count(); i++) {', "\n";
   print '		OPort1Type tuple;', "\n";
   print '		setEventTuple(payload, i, tuple);', "\n";
   print '		submit(tuple, 1); 	', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::setEventTuple(', "\n";
   print '		CNSDataAccess::CPayload& payload,', "\n";
   print '	    const size_t& i,', "\n";
   print '		OPort1Type& tuple) const {', "\n";
   print "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple", "");', "\n";
   print '	', "\n";
   print '	tuple.set_MedicalRecordNumber(current_context_->medicalRecordNumber);', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setMedicalRecordNumber", "");', "\n";
   print '	', "\n";
   print '	tuple.set_Aspect(payload.Aspects().baseTypeString());', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setAspect", "");', "\n";
   print '	', "\n";
   print '	std::string iso8601time = convertTimestamp(payload.ValueList()[i].m_time);', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple convertTimestamp", "");', "\n";
   print '	', "\n";
   print '	tuple.set_Timestamp(iso8601time);', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setTimestamp", "");', "\n";
   print '	', "\n";
   print '	// TODO:  SAMANTHA - this line of code causes the operator to crash', "\n";
   print '	tuple.set_Message(payload.ValueList()[i].value.sValue);', "\n";
   print '	', "\n";
   print '	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: END setEventTuple", "");', "\n";
   print '}', "\n";
   print "\n";
   print '// FIXME: refactor', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processCompositeMeasurements(', "\n";
   print '		CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,', "\n";
   print '		CNSDataAccess::CPayload& payload, ', "\n";
   print '		const std::string& mrn, ', "\n";
   print '		const std::string& aspect, ', "\n";
   print '	    const std::string& correctedTimestamp,', "\n";
   print '	    const std::string units,', "\n";
   print '		const size_t& i,', "\n";
   print '		const float& m, const float& b) {', "\n";
   print '		', "\n";
   print '	std::vector<std::string> compositeElements = *dataSettingsFile.getCompositeElements();', "\n";
   print '	int numComposites = std::min<int>(payload.NumCompositeElements(), compositeElements.size());', "\n";
   print '	SPLAPPTRC(L_DEBUG, "Number of composite elements \'" << numComposites << "\'", "");', "\n";
   print "\n";
   print '	if (numComposites <= 0) {', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print "\n";
   print '	// assume all composite elements have same value type. ', "\n";
   print '	int valueType = getFirstCompositeElementsValueType(compositeElements.at(0));', "\n";
   print "\n";
   print '	if (valueType == 0) {', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '			', "\n";
   print '	// FIXME: do template function', "\n";
   print '	if (valueType == 1) {', "\n";
   print '		float32* data = (float32*)payload.IntCompositeSet(i);', "\n";
   print '		float32 value2;', "\n";
   print '		for (int j = 0; j < numComposites; j++) {', "\n";
   print '			float32& value = data[j];', "\n";
   print "\n";
   print '			float32 value2 = convertSampleSeriesValue(value, m, b);', "\n";
   print '			SPLAPPTRC(L_TRACE, "Sending composite tuple \'" << j << "\' with value \'" << value2 << "\'", "");', "\n";
   print '			sendMeasurementTuple(current_context_->medicalRecordNumber, ', "\n";
   print '								(compositeElements)[j],		', "\n";
   print '								correctedTimestamp,		', "\n";
   print '								units,', "\n";
   print '								convertSampleSeriesValue(value, m, b));', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '	else if (valueType == 2) {', "\n";
   print "\n";
   print '		int32* data = (int32*)payload.IntCompositeSet(i);', "\n";
   print '		int32 value2;', "\n";
   print '		for (int j = 0; j < numComposites; j++) {', "\n";
   print '			int32& value = data[j];', "\n";
   print "\n";
   print '			value2 = convertSampleSeriesValueInt(value, m, b);', "\n";
   print '			SPLAPPTRC(L_TRACE, "Sending composite tuple \'" << j << "\' with value \'" << value2 << "\'", "");', "\n";
   print '			sendMeasurementTupleInt(current_context_->medicalRecordNumber, ', "\n";
   print '								(compositeElements)[j],		', "\n";
   print '								correctedTimestamp,		', "\n";
   print '								units,', "\n";
   print '								convertSampleSeriesValueInt(value, m, b));', "\n";
   print '			', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processMeasurements(', "\n";
   print '		CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,', "\n";
   print '		CNSDataAccess::CPayload& payload, ', "\n";
   print '	    const ClockTime timestamp,', "\n";
   print '	    const std::string units,', "\n";
   print '		const size_t& i,', "\n";
   print '		const float& m, const float& b) {', "\n";
   print '	', "\n";
   print '	//SPLAPPTRC(L_TRACE, "Operator ReadCnsData: setMeasurementTuple, i=" << i, "");', "\n";
   print "\n";
   print '	std::string correctedTimestamp = convertTimestamp(timestamp);', "\n";
   print "\n";
   print '	if (payload.Type() == CNSDataAccess::FLOAT_AGGREGATE) {', "\n";
   print '		float32 value = payload.FloatData()[i];', "\n";
   print '		value = convertSampleSeriesValue(value, m, b);', "\n";
   print '		sendMeasurementTuple(current_context_->medicalRecordNumber, ', "\n";
   print '							payload.Aspects().baseTypeString(),', "\n";
   print '							correctedTimestamp,', "\n";
   print '							units,', "\n";
   print '							value);', "\n";
   print '		', "\n";
   print '	} else if (payload.Type() == CNSDataAccess::INTEGER_AGGREGATE) {', "\n";
   print '		int value = payload.IntData()[i];', "\n";
   print "\n";
   print '		sendMeasurementTuple(current_context_->medicalRecordNumber, ', "\n";
   print '							payload.Aspects().baseTypeString(),', "\n";
   print '							correctedTimestamp,', "\n";
   print '							units,', "\n";
   print '							convertSampleSeriesValueInt(value, m, b));', "\n";
   print '	} else if (payload.Type() == CNSDataAccess::COMPOSITE_AGGREGATE) {', "\n";
   print '		processCompositeMeasurements(', "\n";
   print '				dataSettingsFile, ', "\n";
   print '				payload,', "\n";
   print '				current_context_->medicalRecordNumber, ', "\n";
   print '				payload.Aspects().baseTypeString(),', "\n";
   print '				correctedTimestamp, ', "\n";
   print '				units,', "\n";
   print '				i,', "\n";
   print '				m,', "\n";
   print '				b);		', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// TODO:  SAMANTHA:  Change menthod signature to make it unambiguious', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::sendMeasurementTupleInt(', "\n";
   print '		  const std::string& mrn, ', "\n";
   print '		  const std::string& aspect,', "\n";
   print '		  const std::string& timestamp,', "\n";
   print '		  const std::string& unit,', "\n";
   print '		  const int& value)  {', "\n";
   print '	', "\n";
   print '	OPort0Type tuple;', "\n";
   print "\n";
   print '	tuple.set_MedicalRecordNumber(mrn);', "\n";
   print '	tuple.set_Aspect(aspect);', "\n";
   print '	tuple.set_Timestamp(timestamp);', "\n";
   print '	SPL::rstring unitutf = SPL::Functions::String::convertToUtf8(unit, "ISO-8859-1");	', "\n";
   print '	tuple.set_Unit(unitutf);', "\n";
   print '	', "\n";
   print '	tuple.get_Data().push_back(value);', "\n";
   print '	', "\n";
   print '	submit(tuple, 0); ', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::sendMeasurementTuple(', "\n";
   print '		  const std::string& mrn, ', "\n";
   print '		  const std::string& aspect,', "\n";
   print '		  const std::string& timestamp,', "\n";
   print '		  const std::string& unit,', "\n";
   print '		  const float& value)  {', "\n";
   print '	', "\n";
   print '	OPort0Type tuple;', "\n";
   print "\n";
   print '	tuple.set_MedicalRecordNumber(mrn);', "\n";
   print '	tuple.set_Aspect(aspect);', "\n";
   print '	tuple.set_Timestamp(timestamp);', "\n";
   print '	SPL::rstring unitutf = SPL::Functions::String::convertToUtf8(unit, "ISO-8859-1");	', "\n";
   print '	tuple.set_Unit(unitutf);', "\n";
   print '	', "\n";
   print '	tuple.get_Data().push_back(value);', "\n";
   print '	', "\n";
   print '	submit(tuple, 0); ', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'float32 MY_OPERATOR_SCOPE::MY_OPERATOR::convertSampleSeriesValue(const float32 &value, const float64& m, const float64& b) const {', "\n";
   print '	float32 converted_value = (float32)(((float64)value) * m + b);', "\n";
   print '	return converted_value;', "\n";
   print '}', "\n";
   print "\n";
   print 'int32 MY_OPERATOR_SCOPE::MY_OPERATOR::convertSampleSeriesValueInt(const int32 &value, const float64& m, const float64& b) const {', "\n";
   print '	float32 tmp = (float64)value;', "\n";
   print '	float32 converted_value = (float32)((tmp)* m + b);', "\n";
   print '	return (int32)converted_value;', "\n";
   print '}', "\n";
   print "\n";
   print 'int MY_OPERATOR_SCOPE::MY_OPERATOR::getFirstCompositeElementsValueType(const std::string& firstElement) const {', "\n";
   print "\n";
   print '	std::size_t foundFloat = firstElement.find("Float");', "\n";
   print '	std::size_t foundInt = firstElement.find("Integer");', "\n";
   print '	int valueType = 0; // FIXME: make enum, default undefined', "\n";
   print '	if (foundFloat != std::string::npos) {', "\n";
   print '		valueType = 1;', "\n";
   print '	}', "\n";
   print '	else if (foundInt != std::string::npos) {', "\n";
   print '		valueType = 2;', "\n";
   print '	}', "\n";
   print '	return valueType;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::deleteNextContext() {', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '		delete next_context_;', "\n";
   print '		next_context_ = NULL;', "\n";
   print '		next_is_valid_ = false;', "\n";
   print '		context_change_needed_ = true;', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::createNextContext(const std::string& pid, const std::string& mrn) {', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '	', "\n";
   print '		next_context_ = new ProcessingContext;', "\n";
   print '		next_context_->patientId = pid;', "\n";
   print '		next_context_->medicalRecordNumber = mrn;', "\n";
   print '		next_context_->dataAccess = new CNSDataAccessWrapper::IcuDataAccess();', "\n";
   print '		next_context_->dataAccess->SetRootPath(cns_archive_); ', "\n";
   print '		', "\n";
   print '		next_is_valid_ = true;', "\n";
   print '		', "\n";
   print '		context_change_needed_ = true;', "\n";
   print '		', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::openPatientDirectory(const std::string& pid, const std::string& mrn) {', "\n";
   print '	SPLAPPTRC(L_TRACE, "Attempting to open patient \'" << pid << "\', with medical record number \'" << mrn << "\'...", "");', "\n";
   print "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '		', "\n";
   print '		if (next_context_->dataAccess->OpenPatient(pid)) {', "\n";
   print '			SPLAPPTRC(L_TRACE, "Patient folder successfully opened \'" << pid << "\'.", "");', "\n";
   print '		} else {', "\n";
   print '			// could not open new patient\'s folder - stay with current patient.', "\n";
   print '			delete next_context_;', "\n";
   print '			next_context_ = NULL;', "\n";
   print '			next_is_valid_ = false;', "\n";
   print '			', "\n";
   print '			SPLAPPTRC(L_WARN, "Could not open patient folder with pid \'" << pid << "\'.", "");	', "\n";
   print '		}', "\n";
   print '			', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::getCurrentPatientIsValid() {', "\n";
   print '	bool is_valid = false;', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '	    is_valid = current_is_valid_;', "\n";
   print '	}', "\n";
   print '	return is_valid;', "\n";
   print '}', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::getCurrentPid() {', "\n";
   print '	std::string pid = "";', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '	    if (current_context_ != NULL) {', "\n";
   print '	    	pid = current_context_->patientId;', "\n";
   print '	    }', "\n";
   print '	}', "\n";
   print '	return pid;', "\n";
   print '}', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::getCurrentMrn() {', "\n";
   print '	std::string mrn = "";', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '		if (current_context_ != NULL) {', "\n";
   print '			mrn = current_context_->medicalRecordNumber;', "\n";
   print '		}', "\n";
   print '	}', "\n";
   print '	return mrn;', "\n";
   print '}', "\n";
   print "\n";
   print 'std::vector < CNSDataAccess::CAspects > MY_OPERATOR_SCOPE::MY_OPERATOR::getCurrentAspects() {', "\n";
   print '	std::vector < CNSDataAccess::CAspects > aspects;', "\n";
   print '	{ AutoMutex am (context_mutex_); ', "\n";
   print '		aspects = current_context_->dataAccess->GetStoredTypes();', "\n";
   print '	}', "\n";
   print '	SPLAPPTRC(L_TRACE, "Number of stored aspects found: \'" << aspects.size() << "\'", "");', "\n";
   print '	', "\n";
   print '	return aspects;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::convertTimestamp(const int64 timestamp) const {', "\n";
   print '	time_t seconds = timestamp / 1000000;', "\n";
   print '	int us = timestamp % 1000000;', "\n";
   print "\n";
   print '	struct tm* ptm;', "\n";
   print '	ptm = gmtime (&seconds); ', "\n";
   print "\n";
   print '	char buf[30];', "\n";
   print '	snprintf(buf, 29, "%i-%02i-%02iT%02i:%02i:%02i.%06iZ", ptm->tm_year+1900, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, us);', "\n";
   print "\n";
   print '	std::string result(buf);', "\n";
   print "\n";
   print '	return buf;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
