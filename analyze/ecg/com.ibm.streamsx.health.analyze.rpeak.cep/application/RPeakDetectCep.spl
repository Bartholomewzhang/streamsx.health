namespace application ;

use com.ibm.streamsx.health.ingest.connector::IngestSubscribe ;
use com.ibm.streamsx.health.ingest.types::* ;
use com.ibm.streams.cep::MatchRegex ;
use com.ibm.streamsx.topology.topic::Publish ;
use com.ibm.streamsx.json::TupleToJSON ;
type PeakEvent = rstring patientId, int64 ts, float64 data, float64 max,
	float64 min, int32 count, list<float64> eventData, list<int64> eventTs ;
type RPeakEvent = rstring patientId, int64 ts, float64 data ;
type RREvent = rstring patientId, int64 rrInterval, list<RPeakEvent> events ;

composite RPeakDetectCep
{
	param
		expression<rstring> $subTopic : getSubmissionTimeValue("topic") ;
		expression<rstring> $pubTopicRPeak : "analyze/rpeak/cep/r" ;
		expression<rstring> $pubTopicRR : "analyze/rpeak/cep/rr" ;
		expression<rstring> $signal :  getSubmissionTimeValue("readingCode", "ECG") ;
		expression<float64> $peakThreshold : (float64)getSubmissionTimeValue("peakThreshold", "0.8") ;
	graph
		(stream<Observation> IngestSubscribe_1_out0) as IngestSubscribe_1 =
			IngestSubscribe()
		{
			param
				topic : $subTopic ;
		}

		(stream<PeakEvent> MatchRegex_2_out0) as MatchRegex_2 =
			MatchRegex(Functor_3_out0 as I0)
		{
			param
				pattern : ". rise+ drop drop drop" ;
				predicates : { rise = data >= Last(data), drop = data < Last(data) } ;
				partitionBy : I0.patientId ;
			output
				MatchRegex_2_out0 : max = Max(data), min = Min(data), count = Count(),
					eventData = Collect(data), eventTs = Collect(ts) ;
		}

		(stream<rstring patientId, int64 ts, float64 data> Functor_3_out0) as
			Functor_3 = Functor(IngestSubscribe_1_out0 as I0)
		{
			param
				filter : I0.reading.readingType.code == $signal ;
			output
				Functor_3_out0 : patientId = I0.patientId, ts = I0.reading.ts, data =
					I0.reading.value ;
		}

		() as Publish_4 = Publish(TupleToJSON_5_out0 as inPort0Alias)
		{
			param
				topic : $pubTopicRPeak ;
		}

		(stream<rstring jsonString> TupleToJSON_5_out0) as TupleToJSON_5 =
			TupleToJSON(RPeakEvents as inPort0Alias)
		{
		}

		(stream<RPeakEvent> RPeakEvents) as Custom_6 = Custom(MatchRegex_2_out0 as
			I0)
		{
			logic
				onTuple I0 : if(max - eventData [ 0 ] > $peakThreshold)
				{
					submit({ patientId = patientId, ts = eventTs [ size(eventTs) - 4 ], data =
						max }, RPeakEvents) ;
				}

		}

		(stream<RREvent> RREvents) as Aggregate_7 = Aggregate(RPeakEvents as I0)
		{
			window
				I0 : sliding, count(2), count(1), partitioned ;
			param
				partitionBy: I0.patientId;
			output
				RREvents : rrInterval = I0 [ 0 ].ts - I0 [ 1 ].ts, events = Collect(I0) ;
		}

		() as Publish_8 = Publish(TupleToJSONRR_out0)
		{
			param
				topic : $pubTopicRR ;
		}

		(stream<rstring jsonString> TupleToJSONRR_out0) as TupleToJSONRR =
			TupleToJSON(RREvents as inPort0Alias)
		{
		}

}

